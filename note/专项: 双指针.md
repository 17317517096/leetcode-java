# 专项: 双指针

双指针技巧 和常规的题目: 

* 快慢指针: 判断链表是否有环的问题(141题)，查找重复数字(287题目)；
* 左右指针: 二分查找；
* 滑动窗口算法;

## 代码模板

### 快慢指针相关

1. 判断链表中是否有环

用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

```java
class Solution {
    boolean hasCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
    
            if (fast == slow) return true;
        }
        return false;
    }
}
```

2. 已知链表中含有环，返回这个环的起始位置

当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

为什么? 第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。就是说 如果从相遇点继续前进 k - m 步，也恰好到达环起点。

```java
class Solution {
    ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        // 上面的代码类似 hasCycle 函数
        slow = head;
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

3. 寻找链表的中点

让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。

```java
class Solution {
    ListNode main(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // slow 就在中间位置
        return slow;
    }
}
```

4. 寻找链表的倒数第 k 个元素

使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点。

```java
class Solution {
    ListNode main(ListNode head) {
        ListNode slow, fast;
        slow = fast = head;
        while (k-- > 0) 
            fast = fast.next;
        
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

### 滑动窗口

1. 无重复字符的最长子串

右指针前进，当发现窗口内有重复字符时，左指针前进，直到无重复字符；当窗口内没有重复字符时，更新结果；

```java
public class Solution2 {
    public int lengthOfLongestSubstring(String s) {
        int res, left, right;
        res = left = right = 0;
        Set<Character> set = new HashSet<>();
        while (right < s.length()) {
            Character ch = s.charAt(right);
            while (set.contains(ch)) {
                set.remove(s.charAt(left));
                left++;
            }
            set.add(ch);
            res = Math.max(res, right - left + 1);
            right++;
        }
        return res;
    }
}
```

## leetcode 的双指针专题

* [Two Pointers](https://leetcode.com/tag/two-pointers/)

## 参考资料:

* [labuladong的算法小抄: 双指针技巧总结](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/2.5-shou-ba-shou-shua-shu-zu-ti-mu/shuang-zhi-zhen-ji-qiao)